\documentclass[conference]{IEEEtran}
\usepackage{pdftexcmds}
\usepackage[pdftex]{graphicx}
\usepackage{multirow}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{balance}
\usepackage{amssymb, marvosym}
\usepackage{threeparttable}
\usepackage[bookmarks=false]{hyperref}
\usepackage{url}
\PassOptionsToPackage{hyphens}{url}
\hypersetup{colorlinks=true,breaklinks=true}
\usetikzlibrary{patterns,shapes,arrows}
\newcommand\tab[1][.5cm]{\hspace*{#1}}
\hyphenation{op-tical net-works semi-conduc-tor}
\IEEEoverridecommandlockouts
\raggedbottom
\newcommand{\tool}{tool-recommender-bot}
\newcommand{\pseudosection}[1]{\vspace{2mm} \noindent {\bf #1}}
\newcommand{\pseudosubsection}[1]{\vspace{2mm} {\it #1}}

\begin{document}

% Copyright
%\setcopyright{acmlicensed}

\title{\tool}

\author{\IEEEauthorblockN{Chris Brown and Emerson Murphy-Hill}
\IEEEauthorblockA{Department of Computer Science\\
North Carolina State University\\
Raleigh, NC\\
Email: dcbrow10@ncsu.edu, emerson@csc.ncsu.edu}
}

\maketitle
\begin{abstract}
Recommendation systems were developed to improve the adoption of useful software tools and features designed to save time and effort in completing tasks that are often ignored by users. Previous research suggests that peer-to-peer recommendations is an effective mode of tool discovery, and the receptiveness of recommendees is a vital characteristic in determining the outcome of tool suggestions. To help increase awareness of useful tools, we developed and evaluated a new system \tool~designed to integrate aspects of peer interactions and user receptivity into automated tool recommendations for software developers of real-world applications. Our findings suggest that \tool~is awesome, cool, and very effective in improving tool discovery.
%Software quality is a primary concern of software engineers and users, however developers often ignore useful tools to improve quality and ease debugging for programmers.
\end{abstract}

\begin{IEEEkeywords}
Software Engineering; Tool Recommendation; Tool Discovery; Open Source
\end{IEEEkeywords}

\section{Introduction}
%Importance
Software contains many tools and features designed to make users more efficient and effective in their work. However, despite a wide availability of such useful tools, many are often ignored or underutilized because users do not know of their existence. The amount of tools provided by applications is also continuing to increase, making it more difficult for users to discover helpful tools. This lack of awareness can lead to wasted time and billions of wasted dollars each year.

One area where worker effectiveness and efficiency is extremely important is the software industry. Software has permeated nearly every facet of our society and. Additionally, defects and errors in software cost companies millions of dollars to fix.

Automated recommendation systems can help solve this problem...

But existing recommendations systems are ineffective...

Peer interactions and receptiveness are effective~\cite{vlhcc17}...

We created \tool~to solve this... To evaluate the effectiveness of our approach, we studied the following research questions (RQs): \\

\noindent
\textbf{RQ1:} How often can we expect \tool~to make recommendations?  \\
\textbf{RQ2:} How useful are recommendations from \tool~to developers?  \\

To answer these questions, we evaluated our system on open source Java projects to observe how many tool suggestions would be made based on past changes to the code base and how software developers reacted to receiving recommendations. This research makes the following contributions:

\begin{itemize}
\item introduce the design and evaluation of \tool, a novel approach to improving tool discovery
\item provide implications for designing effective automated recommendation systems.
\end{itemize}

\section{Related Work}

Improving tool discovery...\\

Existing automated tool recommendation systems...\\

Improving awareness of software engineering tools...\\

\section{Tool}
Our approach to improving tool discovery, \tool, aims to increase awareness and use of programming tools among software developers. This section describes the design and implementation of our system.

\subsection{Design}
Previous research shows that recommendations between peers is an effective way to increase tool discovery and adoption~\cite{Murphy-HillPeerInteraction}. Many automated help systems are designed to simulate user-to-user recommendations in order to increase awareness of application tools and features, for instance Microsoft's intelligent office assistant Clippy\cite{Clippy}. 

To better understand what makes peer interactions an effective mode of tool discovery, our prior work observed how colleagues recommend tools to each other while working on tasks. Our results found that \emph{receptiveness} is a significant factor in determining the effectiveness of a tool recommendation, while other characteristics, such as politeness and persuasiveness, do not significantly impact the outcome~\cite{vlhcc17}. We designed \tool~to integrate user receptivity into our approach for making tool recommendations to increase awareness of programming tools.

\pseudosection{Receptiveness}

Previous work emphasizes the importance of receptivity. Fogg outlined best practicies for creating persuasive technology to change user behavior, and argued designers must choose a receptive audience~\cite{FoggPersuasive}. Our prior work defined receptiveness using two criteria introduced by Fogg: 1) demonstrating a desire and 2) familiarity with the target behavior and technology. Below we explain how \tool~was designed to recommend programming tools to software developers based on their desire and familiarity.

\pseudosubsection{1. Desire}

The primary desire of software users is to have enjoyable and problem-free experiences with software. Developers of these applications also have similar desires, to create high-quality and functioning programs for users. A 2002 study revealed that software engineers demonstrate this desire by spending the majority of the software development process and 70-80\% of their time testing and debugging code~\cite{NIST}. To aid developers in finding, fixing, and preventing various issues in code, many different types of tools have been created to help accomplish these tasks. However, despite the existence of effective tools for detecting errors, the number of bugs in software is increasing~\cite{HaveThingsChanged}. We aim to increase awareness of these tools to improve software quality and developer productivity, ultimately meeting users' and developers' desire for less buggy software.

To target this desire of mistake-free code, our initial implementation of \tool~automatically recommends \textsc{Error Prone}.\footnote{http://errorprone.info} \textsc{Error Prone} is a static analysis tool created by Google to check for errors in Java code based on a suite of bug patterns. Static analysis tools can improve software quality by automatically inspecting code without running the program. These tools are useful in debugging and creating desireable applications, however they are often underutilized by software engineers~\cite{Johnson2013Why}. 

\pseudosubsection{2. Familiarity}

Choosing an audience familiar with the target behavior is also vital to increasing adoption. To increase use of helpful programming tools, such as static analysis tools, our system focuses on making recommendations to software engineers within the context of the projects they develop. Familiarity with source code is important for creating software applications, and code understandability is one of the most important factors for software development, maintenance, debugging, and testing~\cite{Understandability}.

To choose a familiar audience, our approach makes recommendations on Github\footnote{https://github.com}, a popular source code management and version control website that hosts millions of projects and serves millions of users. \tool~makes its recommendations on pull requests, or proposed changes to source code submitted by programmers. Developers making these changes should be knowledgeable about the changes they propose as well as the code base to which they are contributing. Our approach suggests \textsc{Error Prone} when reported errors are fixed by developers in pull requests to capitalize on their familiarity with their modifications. The GitHub interface allows users to review and comment on pull requests in situ with the proposed changes, and this is where we make our recommendations.

\subsection{Implementation}

\tool~builds on four key concepts to automatically recommend tools to users and improve tool discovery based on our design goals for targeting developer receptivity.

\pseudosubsection{1. Continuous Integration}

Our system utilizes continuous integration to recommend useful tools before pull request changes are integrated into the main repository, or merged. \tool~is implemented as a plugin for Jenkins, ``the leading open source automation server'' for source code deployment and delivery.\footnote{https://jenkins.io/} The system uses Jenkins to clone Github repositories and periodically check for newly-opened pull requests every 15 minutes. When a new pull request is found, our system uses Jenkins to automatically run our approach to recommend \textsc{Error Prone}.

To analyze the source code, we target projects that use the Maven~\footnote{https://maven.apache.org/} build automation and software management tool for Java applications. Our approach uses Maven to automatically handle dependencies and perform the static analysis when the project builds. We inject \textsc{Error Prone} as a Maven plugin to repository's \textit{pom.xml} project object model file to add it to the build process. \tool~then builds both the original version of the code before the proposed changes were made (base) and the changed version of the repository with the pull request modifications implemented (head) to inspect differences. Using Maven allows \tool~to run on a large number of Java projects that use the popular build tool and also makes our approach extendable to recommend other tools implemented as Maven plugins in future work. 

\pseudosubsection{2. Fix Identification}

After analyzing the base and head versions of the code, our approach parses the build output of each version to determine if any reported errors were fixed in the pull request. \textsc{Error Prone} identifies faults found in the source code, and we developed an algorithm using that information to determine if changes made to the code in the head version fix the identified bug. Our technique uses the code differencing tool GumTree~\cite{GumTree} to identify actions (addition, delete, insert, move, and update) performed between pull request versions and parse the code to convert the text into abstract syntax trees. 

To determine if an error was fixed, we take several things into consideration: First, our approach ignores instances where only delete actions were detected between the base and head versions of a file. This avoids making recommendations in situations where bugs were removed but not necessarily fixed in refactoring tasks, such as deleting and moving code, renaming classes, etc. Second, we ignore occurrences of deprecated classes because, similarly, the error reported was not fixed but removed. Third, we do not consider error fixes that were made by changes to a different file because we want to make recommendations where the developer is familiar with the changes that occurred. These help us minimize the number of false positives and errant recommendations in our approach.

\pseudosubsection{3. Fix Localizaton}

When a fix is identified in the pull request, \tool~then aims to find the location of the fix in the head version. To find the modified line that fixed a bug, we use GumTree to parse the Java file and convert it into abstract syntax trees. We look for the action closest to the offset of the error node calculated from the bug line number reported by \textsc{Error Prone}. If the closest action is not a delete, then our approach take the location takes the location of that action. Otherwise, if the line was removed our algorithm searches for the closest sibling node or if none exists then the location of the parent.

\pseudosubsection{4. Code Review}

Code reviews from co-workers are often standard practice in software development. Pull requests are the primary method of code contributions and code reviews on Github~\cite{PullRequestReview}. Our approach simulates peer reviews by making recommendations for static analysis tools as a comment to the pull request. Github provides functionality for making comments at specific lines of code in a pull request, and \tool~recommends \textsc{Error Prone} as a comment at the fix location line from the previous step. Additionally, our system  uses language similar to comments between co-workers in recommendations, such as using ``Good job!'' to compliment developers on their work'~\cite{?}.

To further increase the adoption of static analysis tools, we report other instances of similar errors found by \textsc{Error Prone} in the base version of the code. In the recommendation, \tool~adds links to at most two locations where \textsc{Error Prone} found the same error as the one that was fixed. We hope this encourags the use of \textsc{Error Prone} to find more bugs in the pull request before the code is merged into the code base. Figure 1 presents a recommendation from our system on a pull request review.

\section{Methodology}

\subsection{Projects}

To evaluate the effectiveness of our recommendation system, we assessed \tool~on five real-world open-source software applications. To narrow down projects for our evaluation, we picked Github repositories that met the following criteria:

\begin{itemize}
\item one of the top Trending projects\footnote{https://github.com/trending} on Github based on activity by the community at the time of this writing,
\item primarily written in the Java programming language\footnote{https://java.com},
\item build with Maven,
\item and are owned by a GitHub organization, instead of personal user account projects.
\end{itemize}

\begin{table}
	\centering
	\caption{Evaluation Projects}
	\begin{tabular}{|l|l|l|c|}
		\hline
		\textbf{Project} & \textbf{Java Files} & \textbf{LOC} & \textbf{Pull Requests} \\
		\hline
%		spring-boot\footnote{https://github.com/spring-projects/spring-boot.git} &  &  & \\
%		\hline
%		dubbo\footnote{https://github.com/alibaba/dubbo.git} &  &  & \\
%		\hline
%		guava\footnote{https://github.com/google/guava.git}  &  &  & \\
%		\hline
%		retrofit\footnote{https://github.com/square/retrofit.git}  &  &  & \\
%		\hline
%		rocketmq\footnote{https://github.com/apache/rocketmq.git}  &  &  & \\
%		\hline
		\end{tabular}
	\begin{tablenotes}
        \item[1] Details on projects used for study including GitHub repository name, number of Java files, lines of Java code, and total pull requests.
    \end{tablenotes}
	\label{tools}
\end{table}


\subsection{Study Design}

We divided our study into two segments to address each research question:

\subsubsection{RQ1}

Last 100 pull requests on repositories...

\subsubsection{RQ2}

Followed up with pull request authors to gather data on recommendation...

\section{Results}

\subsection{How often can we expect \tool~to make recommendations?}

Tons of recommendations... \\

No false positives... \\

\subsection{How useful are recommendations from \tool~to developers?}

Excellent responses from recommendees...\\

Statistically significant data...

\section{Discussion}

\subsection{Observations}

\subsection{Implications}

Here's what our results say about ways to improve tool recommendation systems...

\section{Limitations}

Internal\\

An external threat to the validity of our study is that we only observed open source projects hosted on Github in our evaluation. Our results may not generalize to closed source software projects and their developers. To minimize this, we selected popular real-world software applications on Github owned by organizations to avoid the use of personal development projects. Additionally, our recommendation system has limited generalizablility due to the fact we currently only assess recommendations for the Error Prone static analysis tool on Java projects that build with Maven. Future work will look to extend \tool~to include different types of tools, programming languages, and build systems.

\section{Future Work}

More tools to recommend (static analysis, security, etc.) \\

More programming languages instead of just java...\\

More build systems (ant, gradle, TravisCI, bazel)...\\

\section{Conclusion}

\tool is awesome

%\balance
%\section{Acknowledgments}

%Thanks to all of the student and professional data analysts who volunteered for this study.

% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{paper}  
% You must have a proper ''.bib'' file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!

%% That's all folks!
\end{document}
